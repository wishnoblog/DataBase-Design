這本書寫得很好，可惜台灣沒有廠商翻譯的樣子
很多時候學校教的資料庫使用或者語言使用，
多數老師其實沒太多實務經驗，我最喜歡舉的例子是，
你可以問老師教授有沒有跟同事寫過一個專案後端有10萬行的程式碼的網站。
多數的老師其實沒有的，一兩萬行就很了不起了。

這本寫了很多實務經驗，以及告訴我們怎麼把資料庫設計「好」。

我在網路上找到有人位這本書寫了摘要

# 第一部分 

----------

##第1章 关系数据库##
### 数据库类型 
数据库分为**操作型数据库**(operational database)和**分析性数据库**(analytical database)。
#### 操作性数据库 ####
说句人话就是经常更改内容的数据库，所以主要用于联机事务处理(online transaction processing,OLTP)*联机事务处理这个鬼畜的名字是英文翻译过来的，别纠结*，即需要收集、修改和维护日常数据的情况。想网上商城的存货数量，就是使用操作性数据库的，因为他的数据总是处于不断更新的状态。

#### 分析性数据库 ####
与操作性数据库对应，就是数据不经常改动的，所以主要用于联机分析处理(online analytical processing,OLAP)*又一个鬼畜的名字*，用来存储并追踪历史性和时间性的数据，从而根据这些数据做出判断与预测，例如根据以往的股市行情判断这支股票是否会涨。

----------
### 早期数据库模型 ###
早期的数据库模型有**层次结构模型**(hierarchical database model)和**网状数据库模型**(network database model)。
#### 层次结构模型 ####
> 这种数据库中的数据是按照层次结构组织的，通常图解为倒置的树状结构。其中一个表作为倒置树状图的“根”，其他表则是由根生发的枝条。

本来还有很多的内容，但是在这里不介绍了，主要是计算机存储的原因，跟我们后面的设计无关，所以了解一下就好。
#### 网状数据库模型 ####
> 网状数据库的结构用术语**节点**(node)和**集合结构**(set structure)表示。

> 一个节点表示一个记录集合，一个集合结构建立并表示网状数据库中的一种关系。

&nbsp;&nbsp;&nbsp;&nbsp;说句人话就是一个节点可以理解为表，而集合结构则表示表与表之间的联系。具体内容看下图。

&nbsp;&nbsp;&nbsp;&nbsp;接着来说说这种模型的特点，比起上面的层次结构模型，多了一个集合结构的东西，感觉这玩意很像后来的主键和外键，将两个节点联系起来。

----------
### 关系数据库模型
也就是我们现在最常见的数据库模型，与近几年兴起的**nosql**(not only sql)，非关系型数据库对应，boss般的存在。
#### 关系型数据库的优势
- 内置多层次完整性。字段级：确保数据的准确性，表层次：确保主键是不重复的，关系层次：主、外键约束，业务层次：从业务本身而言数据无误。*这里了解一下就好，后面会有解释的*

- 数据在逻辑和物理上都独立于数据库的应用。
> 无论是用户更改数据库的逻辑设计，还是数据库软件供应商更改数据库的物理实现，都不会对建立在该数据库上的应用程序带来不利影响。*简单来说就是不关我们的事*

- 确保数据一致性(data consistency)和准确性(accuracy)。

- 简便的数据检索(data retrieval)。

#### 后关系模型
新型的数据库模型：**面向对象**(object-oriented)数据库和**对象关系**(object-relational)数据库。知道就好，我也不知道这俩货是什么，以后用到再说。
## 第2章 设计目标
*有目标和诱惑才能更好的学习嘛*
### 学习优秀设计方法学的益处
- 提供设计健全数据库所需的技能。
- 提供一些列组织有序的技术引导你逐步完成设计过程。
- 帮助你将失误和设计重复降至最低。
- 让设计过程变得更为简单，并减少设计数据库所花时间。
- 帮助你更充分，更高效的理解和使用RDBMS(Relational Database Manager System)应用程序。(这里我插一句，一般的RDBMS应用程序其实就是自动生成sql语句，但是不能保证生成的sql语句正确，所以最好能自己手写原生sql语句)

----------
### 优秀的设计目标
- 数据库应支持设定的和即时的信息检索。(这里我插一句，设定的查询：视图)
- 正确且高效的构建表。
- 数据完整性落实到字段、表和关系层次。
- 数据库支持与组织相关的业务规则。
- 数据库适应未来发展。

----------

### 优秀设计的好处
- 数据库结构易于修改和维护。
- 数据易于修改。
- 信息易于检索。
- 终端用户易于开发和创建。

----------

### 数据库设计方法
1. 需求分析(requirements analysis)
2. 数据建模(data modeling)
3. 规范化(Normalization)

## 第3章 术语
终于到了重点部分了，为了以后的讲解以及阅读、浏览数据库相关的文章与网站，本章一定要hold住。

本章中定义了四种类型的术语：**关于值的术语**(value-related)、**关于结构的术语**(structure-related)、**关于关系的术语**(relationship-related)、**关于完整性的术语**(integrity-related)。

----------

### 关于值的术语 ###
#### 数据 ####
data，说人话就是存储在表中的数据。
#### 信息 ####
执行sql语句后展现的结果。注意区分数据与信息的区别：
> 储存的是**数据**，检索的是**信息**

### 空值 null ###
null，注意不要一时脑抽把null和0、空字符串理解成一样的玩意，这里讲一个null在数学计算中的问题：

> 带有null的计算结果均为null

----------
### 关于结构的术语 ###
#### 表 ####
“查谁裱”了，哈哈哈，玩一个老梗。关系型数据库中的所有数据都存储在**关系**中，用户视之为**表**。每种关系由**记录**(在数学理论中叫元组)，和**字段**(在数学理论中叫属性)。
其中表可以代表一个**对象** 或者 **事件**。

- 代表**对象**的表，拿人举例子，字段有height、sex、firstName、lastName等
- 代表**事件**的表，拿预约医生举例子，字段有PatientID、Visit Date、Visit Time、Doctor Name等。

这里再按照表的作用分一下类
> 一个存储数据以提供信息的表称为**数据表**(data table)，该类表中的数据是经常被修改的，结合下面的表类型就很好理解了。

> **验证表**(validation table)，也称为**查找表**(lookup table)存储专门用于实现数据完整性的数据。举个例子就能理解了，例如一个存储了中国全部省份的表就叫 **查找表**，因为其中的数据不是经常修改的，相反是经常被拿来读取的。
#### 字段 ####
field，用过数据库的都知道，这里就不解释了。

设计不当的数据库中就会存在下面3中类型的字段：

- **复合**字段(multipart field)，也被称为**合成**字段(composite field)
- [**多值**字段(multivalued field)，其包含了多个相同类型的值](#mul)
- **计算**字段(calculated field)，包含一个串联文本值或一个数学表达式的结果。

上面这样讲可能太空泛了，这里直接看一个表的例子就容易理解了。

| Client Full Name | Client City,CityID  | Parent Name|
| ------------- |:-------------:| -----:|
| Susan  Black     | Seattle,WA 98125 | John |
| Marvin Russo      |    Seattle,WA 98125   |   John,Sandi |
| Kira | Olympia,WA 98504      |   Fisrt |
第一个Client Full Name就是**计算**字段，Client City,CityID就是**复合**字段，Parent Name就是 **多值**字段。

#### 记录 ####
就是存储在表中的数据。

##### 视图 #####
将查询过程存储起来，下次直接调用视图就可以执行跟上次一样的查询了，所以！视图存储的不是一个查询结果，而是查询过程，直观一点就是你的sql语句。使用视图的一个好处是调用视图时，表结构、字段类型等对与用户来说是不可见的，所以避免了用户直接操作数据库。

#### 键 ####
**主键**(primary key)和**外键** (foreign key)，使用过数据库的人可能很好理解这两货的含义，但是防止自己以后忘记，这里记一下**外键** 的含义，**外键** 其实是另一张表中的**主键**，但是被移动到了另一张表中，对于该表，此**主键** 是外来的，所以称为**外键**。

#### 索引 #####
曾今很纠结于**键**和**索引** 的区别，其实这样理解索引比较恰当，如果把数据库必做一本书的话，那么**键**就是其中的每一部分的标题，而**索引** 就是书签，**索引**中的内容就是**键**的内容，这样人们根据此书签快速查询到数据，而不需要一页一页的去查找书中的标题，直到查找到自己的标题。

----------
### 关于关系的术语 ###
两张表之间有的采用主、外键联系在一起，有的则是靠第三张表**联系表**(linking table)，也叫做**关联表**(associate table)联系在一起。具体例子下面会有的。
> 关系是关系数据库的重要组成部分。

- 关系让你能够创建多表视图。
- 对于数据完整性来说，关系非常关键，因为它有助于减少冗余数据和消除重复数据。

接下来使用3种方式描述关系的特征：

1. 表之间存在的关系类型
2. 每个表的参与方式
3. 每个表的参与度

#### 表之间存在的关系类型 ####
注意，接下来讨论的字段都是主键和外键。

- **一对一**，即一个主键记录只与一个外键记录想匹配，如下表

|CityID|City Name|
|:|
|1|NingBO |
|2|HangZhou|

|Name|CityID|Blood|
|:|
|TT|1|A|
|YY|2|B|

其中第二张表的CityID就是外键，而CityID与Name主键之间是**一对一**的，因为一个人同一时刻只能出现在一个地方。

- **一对多**，与上面类似的答案，一个主键对应多个外键，如个人信息表中的*喜欢的食物* 外键字段，就可以是**一对多**的关系，一个人可以同时喜欢很多食物。这个时候和上面的**一对多**比较一下就可以知道，都是将一张表中的**主键**内嵌到另一张表中作为一一个字段的，这也就是**外键**的由来，记住这一点，下面讨论 **多对多**时要用到。

- **多对多**，这个很重要，所以重点讲解！

> 如果第一个表中的单个记录可以与第二个表中的**多个**记录相关联，且第二个表中的单个记录可以与第一个表中的**多个**记录相关联，这两表之间的关系就被称为**多对多**关系。使用**联系表**可以建立器这种关系。这样讲很空泛，我们来看下面这个例子：

|StudentID|Student Name|
|:|
|1|TT|
|2|YY|

|ClassID|Class Name|
|:|
|1|Math|
|2|Chinese|

这两张表可以使用上面的方式将另一张表的**主键**插入到自己表中作为**外键**的形式来存储数据吗？答案是的，但是这样会造成严重的数据冗余，我们来试一下：

|StudentID|Student Name|Telephone|Address|ClassID|
|:|
|1|TT|120|Hospital|1|
|1|TT|120|Hospital|2|
|1|TT|120|Hospital|3|
|2|YY|110|kotwalle|1|
|2|YY|110|kotwalle|4|
|2|YY|110|kotwalle|7|

|ClassID|Class Name|Class Room|StudentID|
|:|
|1|Math|NA110|1|
|1|Math|NA110|2|
|1|Math|NA110|3|
|1|Math|NA110|4|
|2|Physical|NB110|1|
|2|Physical|NB110|2|
|2|Physical|NB110|3|

可以很明显的看出数据冗余了，拿TT来举例子，他因为要同时上ClassID为1.2.3的课，结果他的记录就多了3条，而且可以看到Student Name、Telephone、Address字段都是重复的，这就是数据冗余了，也有人说那我可以把ClassID字段作为字符串来存储啊，存储成‘1，2，3’的形式，不是一样可以读吗？这样想的人可以去看一下这里<a name="mul">**多值**字段</a>，然后喝杯咖啡，休息一下再来看接下来的内容。

所以最好的办法就是使用我们前面介绍的**关联表**，具体实施请看下面：

|StudentID|Student Name|Telephone|Address|
|:|
|1|TT|120|Hospital|
|2|YY|110|kotwale|

再来课程表

|ClassID|Class Name|Class Room|
|:|
|1|Math|NA110|
|2|physical|NB110|

接下来就是见证奇迹的时刻了。

|StudentID|ClassID|
|:|
|1|1|
|1|2|
|1|3|
|2|1|
|2|4|
|2|7|

第三张表就是关联表，他将ClassID和StudentID之间的**多对多**关系整合到了一张表中，最大程度的减少了数据的冗余。

#### 每个表参与的方式 ####

- **强制的**(mandatory)
- **可选的**(optional)

> - 如果在向TABLE_B输入记录之前，必须向TABLE_A输入至少一条记录，那么TABLE_A的参与就被视为**强制**的

> - 如果在向TABLE_B输入记录之前，无须向TABLE_A输入任何记录，那么TABLE_A的参与就是可选的。

很容易理解，至于为什么要这样，在相应的业务需求下就很容易理解了，这里记住就好了。

#### 参与度 ####

> 通过找出TABLE_B可以与TABLE_A中**单个**记录像关联的最多：max记录数和最少：min记录数，就可以确定TABLE_B的参与度了。

表示成TABLE_B的参与度为--**min,max**，注意，中间用逗号隔开。


----------
### 关于完整性的术语 ###
#### 字段说明 ####

> 字段说明(field specification，其传统叫法为**域**[domain])，描述一个字段的所有元素。每个字段说明包含三种元素：**一般元素**(general element)、**物理元素**(physical element)和**逻辑元素**(logical element)。 

- **一般元素**组成字段最基本的信息，包括字段名称(field name)、描述(description)和父表(parent table)等选项。

- **物理元素**决定字段建构方式以及向使用者呈现它的方式。这个范畴包括数据类型(data type)、长度(length)以及显示格式(display format)等等。

- **逻辑元素**描述存储在字段中的值，它包括所需值(required value)、值的范围(range of value)以及默认值(default value)等等。

这里了解就好，鬼知道这玩意什么意思。

#### 数据完整性 ####
**数据完整性**(data integrity)指的是数据的有效性、一致性和准确性。

在数据库设计过程中，要实现四种类型的数据完整性。

1.**表层次完整性**(table-level integrity,传统上称作**实体完整性**)确保表中无重复记录，并且确保表中字段对每个记录的标识是唯一的且不是空值。

2.**字段级完整性**(field-level integrity，传统上称作“”域完整性**)确保每个字段的结构健全，确保每个字段的值有效、一致性且准确，确保相同类型的字段在真个数据库中定义一致。

3.**关系层次完整性**(relationship-level integrity，传统上称作**参照完整性**)，确保两表之间的关系是健全的，且无论哪个表中输入、更新或删除数据，两表中的数据始终保持同步。

4.**业务规则**就是基于切实的业务流程设计相应的数据库了。
